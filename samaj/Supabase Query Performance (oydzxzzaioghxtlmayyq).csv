rolname,query,calls,total_time,min_time,max_time,mean_time,avg_rows,rows_read,debug_hit,debug_read,cache_hit_rate,prop_total_time
authenticator,SELECT name FROM pg_timezone_names,68,10260.547778,52.816155,991.542768,150.8904085,1194,81192,0,0,0,21.2835049122098
supabase_admin,"LOCK TABLE ""realtime"".""schema_migrations"" IN SHARE UPDATE EXCLUSIVE MODE",80,4718.24809,0.011676,588.362985,58.978101125,0,0,60,0,100.0000000000000000,9.78708530706864
postgres,"with f as (
      
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = $5
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $6 then $7
    else f.prosrc
  end as definition,
  case
    when l.lanname = $8 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $9) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, $10) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = $11 then $12
    when f.provolatile = $13 then $14
    when f.provolatile = $15 then $16
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $17))[$18] as param,
          (string_to_array(unnest(proconfig), $19))[$20] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $21, t2.mode,
        $22, name,
        $23, type_id,
        -- Cast null into false boolean
        $24, COALESCE(has_default, $25)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $26 then $27
            when t1.mode = $28 then $29
            when t1.mode = $30 then $31
            when t1.mode = $32 then $33
            else $34
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid

    )
    select
      f.*
    from f
   where schema NOT IN ($35,$36,$37)

-- source: dashboard
-- user: 211d0aef-10ec-48e7-a4d9-ee3d29cd1988
-- date: 2025-09-21T19:46:03.652Z",29,3791.622725,104.185829,246.797274,130.745611206897,100,2910,15384,0,100.0000000000000000,7.86498173770152
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1920.827334,1920.827334,1920.827334,1920.827334,1,1,100220,0,100.0000000000000000,3.98438162203701
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1808.781482,1808.781482,1808.781482,1808.781482,1,1,101598,0,100.0000000000000000,3.75196435806326
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1797.795729,1797.795729,1797.795729,1797.795729,1,1,101555,0,100.0000000000000000,3.72917655637872
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1784.329023,1784.329023,1784.329023,1784.329023,1,1,100138,0,100.0000000000000000,3.70124250163781
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1772.744571,1772.744571,1772.744571,1772.744571,1,1,101481,0,100.0000000000000000,3.6772128156618
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1771.632568,1771.632568,1771.632568,1771.632568,1,1,99876,0,100.0000000000000000,3.67490618234894
postgres,"with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment from pg_class c join pg_namespace nc on nc.oid = c.relnamespace where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg(jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname )) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on (a.attrelid = c.oid and a.attnum = any(i.indkey)) join pg_namespace n on c.relnamespace = n.oid where i.indisprimary group by i.indrelid ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $20, c.oid::int8, $21, c.conname, $22, c.confdeltype, $23, c.confupdtype, $24, nsa.nspname, $25, csa.relname, $26, sa.attname, $27, nta.nspname, $28, cta.relname, $29, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $30 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $31, (a.attrelid || $32 || a.attnum), $33, c.oid::int8, $34, nc.nspname, $35, c.relname, $36, a.attnum, $37, a.attname, $38, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $39 end, $40, case when t.typtype = $41 then case when bt.typelem <> $42::oid and bt.typlen = $43 then $44 when nbt.nspname = $45 then format_type(t.typbasetype, $46) else $47 end else case when t.typelem <> $48::oid and t.typlen = $49 then $50 when nt.nspname = $51 then format_type(a.atttypid, $52) else $53 end end, $54, case when t.typtype = $55 then case when nt.nspname <> $56 then concat(nt.nspname, $57, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $58, a.attidentity in ($59, $60), $61, case a.attidentity when $62 then $63 when $64 then $65 else $66 end, $67, a.attgenerated in ($68), $69, not (a.attnotnull or t.typtype = $70 and t.typnotnull), $71, ( b.relkind in ($72, $73) or (b.relkind in ($74, $75) and pg_column_is_updatable(b.id, a.attnum, $76)) ), $77, uniques.table_id is not null, $78, check_constraints.definition, $79, col_description(c.oid, a.attnum), $80, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $81::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $82 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$83] as ordinal_position from pg_catalog.pg_constraint where contype = $84 and cardinality(conkey) = $85 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$86] as ordinal_position, substring( pg_get_constraintdef(oid, $87), $88, length(pg_get_constraintdef(oid, $89)) - $90 ) as definition from pg_constraint where contype = $91 and cardinality(conkey) = $92 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $93 and not a.attisdropped group by a.attrelid ) select case b.relkind when $94 then jsonb_build_object( $95, b.relkind, $96, b.id, $97, b.schema, $98, b.name, $99, b.rls_enabled, $100, b.rls_forced, $101, ts.replica_identity, $102, ts.bytes, $103, ts.size, $104, ts.live_rows_estimate, $105, ts.dead_rows_estimate, $106, b.comment, $107, coalesce(pk.primary_keys, $108::jsonb), $109, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $110::jsonb ), $111, coalesce(c.columns, $112::jsonb) ) when $113 then jsonb_build_object( $114, b.relkind, $115, b.id, $116, b.schema, $117, b.name, $118, b.rls_enabled, $119, b.rls_forced, $120, ts.replica_identity, $121, ts.bytes, $122, ts.size, $123, ts.live_rows_estimate, $124, ts.dead_rows_estimate, $125, b.comment, $126, coalesce(pk.primary_keys, $127::jsonb), $128, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $129::jsonb ), $130, coalesce(c.columns, $131::jsonb) ) when $132 then jsonb_build_object( $133, b.relkind, $134, b.id, $135, b.schema, $136, b.name, $137, (pg_relation_is_updatable(b.id, $138) & $139) = $140, $141, b.comment, $142, coalesce(c.columns, $143::jsonb) ) when $144 then jsonb_build_object( $145, b.relkind, $146, b.id, $147, b.schema, $148, b.name, $149, $150, $151, b.comment, $152, coalesce(c.columns, $153::jsonb) ) when $154 then jsonb_build_object( $155, b.relkind, $156, b.id, $157, b.schema, $158, b.name, $159, b.comment, $160, coalesce(c.columns, $161::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join columns c on b.id = c.table_id",178,1769.118761,7.314163,46.760685,9.93886944382023,1,178,381345,0,100.0000000000000000,3.66969178007818
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1766.880352,1766.880352,1766.880352,1766.880352,1,1,99866,0,100.0000000000000000,3.66504863723846
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1758.98746,1758.98746,1758.98746,1758.98746,1,1,100142,0,100.0000000000000000,3.64867637239567
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1746.381518,1746.381518,1746.381518,1746.381518,1,1,99868,0,100.0000000000000000,3.62252780466956
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1739.292799,1739.292799,1739.292799,1739.292799,1,1,99880,0,100.0000000000000000,3.60782363985086
postgres,"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",1,1729.27974,1729.27974,1729.27974,1729.27974,1,1,99863,0,100.0000000000000000,3.58705350213271
authenticator,"WITH
-- Recursively get the base types of domains
base_types AS (
  WITH RECURSIVE
  recurse AS (
    SELECT
      oid,
      typbasetype,
      typnamespace AS base_namespace,
      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type
    FROM pg_type
    UNION
    SELECT
      t.oid,
      b.typbasetype,
      b.typnamespace AS base_namespace,
      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type
    FROM recurse t
    JOIN pg_type b ON t.typbasetype = b.oid
  )
  SELECT
    oid,
    base_namespace,
    base_type
  FROM recurse
  WHERE typbasetype = $5
),
arguments AS (
  SELECT
    oid,
    array_agg((
      COALESCE(name, $6), -- name
      type::regtype::text, -- type
      CASE type
        WHEN $7::regtype THEN $8
        WHEN $9::regtype THEN $10
        WHEN $11::regtype THEN $12
        WHEN $13::regtype THEN $14
        ELSE type::regtype::text
      END, -- convert types that ignore the length and accept any value till maximum size
      idx <= (pronargs - pronargdefaults), -- is_required
      COALESCE(mode = $15, $16) -- is_variadic
    ) ORDER BY idx) AS args,
    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments
      WHEN $17 THEN $18
      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)
      ELSE $26
    END AS callable
  FROM pg_proc,
       unnest(proargnames, proargtypes, proargmodes)
         WITH ORDINALITY AS _ (name, type, mode, idx)
  WHERE type IS NOT NULL -- only input arguments
  GROUP BY oid
)
SELECT
  pn.nspname AS proc_schema,
  p.proname AS proc_name,
  d.description AS proc_description,
  COALESCE(a.args, $27) AS args,
  tn.nspname AS schema,
  COALESCE(comp.relname, t.typname) AS name,
  p.proretset AS rettype_is_setof,
  (t.typtype = $28
   -- if any TABLE, INOUT or OUT arguments present, treat as composite
   or COALESCE(proargmodes::text[] && $29, $30)
  ) AS rettype_is_composite,
  bt.oid <> bt.base_type as rettype_is_composite_alias,
  p.provolatile,
  p.provariadic > $31 as hasvariadic,
  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,
  coalesce(func_settings.kvs, $36) as kvs
FROM pg_proc p
LEFT JOIN arguments a ON a.oid = p.oid
JOIN pg_namespace pn ON pn.oid = p.pronamespace
JOIN base_types bt ON bt.oid = p.prorettype
JOIN pg_type t ON t.oid = bt.base_type
JOIN pg_namespace tn ON tn.oid = t.typnamespace
LEFT JOIN pg_class comp ON comp.oid = t.typrelid
LEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass
LEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38
LEFT JOIN LATERAL (
  SELECT
    array_agg(row(
      substr(setting, $39, strpos(setting, $40) - $41),
      substr(setting, strpos(setting, $42) + $43)
    )) as kvs
  FROM unnest(proconfig) setting
  WHERE setting ~ ANY($2)
) func_settings ON $44
WHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)
AND prokind = $47
AND p.pronamespace = ANY($1::regnamespace[])",68,1641.081383,17.985404,62.496032,24.13354975,1,102,102737,118,99.8852753876816878,3.40410321477249
supabase_storage_admin,"-- postgres-migrations disable-transaction
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_objects_lower_name ON storage.objects ((path_tokens[level]), lower(name) text_pattern_ops, bucket_id, level)",1,541.918359,541.918359,541.918359,541.918359,0,0,382,1,99.7389033942558747,1.12410392752358
authenticator,"WITH
-- Recursively get the base types of domains
base_types AS (
  WITH RECURSIVE
  recurse AS (
    SELECT
      oid,
      typbasetype,
      typnamespace AS base_namespace,
      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type
    FROM pg_type
    UNION
    SELECT
      t.oid,
      b.typbasetype,
      b.typnamespace AS base_namespace,
      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type
    FROM recurse t
    JOIN pg_type b ON t.typbasetype = b.oid
  )
  SELECT
    oid,
    base_namespace,
    base_type
  FROM recurse
  WHERE typbasetype = $4
),
columns AS (
    SELECT
        c.oid AS relid,
        a.attname::name AS column_name,
        d.description AS description,
        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column
        CASE
          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)
          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)
          WHEN a.attgenerated = $9 THEN $10
          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text
        END AS column_default,
        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,
        CASE
            WHEN t.typtype = $12 THEN
            CASE
                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)
                ELSE format_type(a.atttypid, a.atttypmod)
            END
            ELSE
            CASE
                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)
                ELSE format_type(a.atttypid, a.atttypmod)
            END
        END::text AS data_type,
        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,
        information_schema._pg_char_max_length(
            information_schema._pg_truetypid(a.*, t.*),
            information_schema._pg_truetypmod(a.*, t.*)
        )::integer AS character_maximum_length,
        bt.base_type,
        a.attnum::integer AS position
    FROM pg_attribute a
        LEFT JOIN pg_description AS d
            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass
        LEFT JOIN pg_attrdef ad
            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
        JOIN pg_class c
            ON a.attrelid = c.oid
        JOIN pg_type t
            ON a.atttypid = t.oid
        LEFT JOIN base_types bt
            ON t.oid = bt.oid
        LEFT JOIN pg_depend seq
            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18
    WHERE
        NOT pg_is_other_temp_schema(c.relnamespace)
        AND a.attnum > $19
        AND NOT a.attisdropped
        AND c.relkind in ($20, $21, $22, $23, $24)
        AND c.relnamespace = ANY($1::regnamespace[])
),
columns_agg AS (
  SELECT
    relid,
    array_agg(row(
      column_name,
      description,
      is_nullable::boolean,
      data_type,
      nominal_data_type,
      character_maximum_length,
      column_default,
      coalesce(
        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),
        $25
      )
    ) order by position) as columns
  FROM columns
  GROUP BY relid
),
tbl_pk_cols AS (
  SELECT
    r.oid AS relid,
    array_agg(a.attname ORDER BY a.attname) AS pk_cols
  FROM pg_class r
  JOIN pg_constraint c
    ON r.oid = c.conrelid
  JOIN pg_attribute a
    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)
  WHERE
    c.contype in ($26)
    AND r.relkind IN ($27, $28)
    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)
    AND NOT pg_is_other_temp_schema(r.relnamespace)
    AND NOT a.attisdropped
  GROUP BY r.oid
)
SELECT
  n.nspname AS table_schema,
  c.relname AS table_name,
  d.description AS table_description,
  c.relkind IN ($31,$32) as is_view,
  (
    c.relkind IN ($33,$34)
    OR (
      c.relkind in ($35,$36)
      -- The function `pg_relation_is_updateable` returns a bitmask where 8
      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.
      -- it's possible to insert into the relation.
      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39
    )
  ) AS insertable,
  (
    c.relkind IN ($40,$41)
    OR (
      c.relkind in ($42,$43)
      -- CMD_UPDATE
      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46
    )
  ) AS updatable,
  (
    c.relkind IN ($47,$48)
    OR (
      c.relkind in ($49,$50)
      -- CMD_DELETE
      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53
    )
  ) AS deletable,
  coalesce(tpks.pk_cols, $54) as pk_cols,
  coalesce(cols_agg.columns, $55) as columns
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass
LEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid
LEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid
WHERE c.relkind IN ($58,$59,$60,$61,$62)
AND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)
AND not c.relispartition
ORDER BY table_schema, table_name",68,422.519354,1.149463,44.706518,6.21351991176471,31,2115,39449,38,99.9037657963380353,0.876433981979429
supabase_admin,"SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,
       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (
  SELECT a.atttypid
  FROM pg_attribute AS a
  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped
  ORDER BY a.attnum
)

FROM pg_type AS t
LEFT JOIN pg_type AS d ON t.typbasetype = d.oid
LEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)
WHERE (t.typrelid = $4)
AND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",9,304.678167,4.399001,124.782965,33.8531296666667,210,1897,23441,0,100.0000000000000000,0.631995426003618
postgres,"SELECT
    tbl.schemaname,
    tbl.tablename,
    tbl.quoted_name,
    tbl.is_table,
    json_agg(a) as columns
  FROM
    (
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,
        $2 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind = $3
        AND n.nspname not in ($4, $5, $6)
        AND n.nspname not like $7
        AND n.nspname not like $8
        AND has_schema_privilege(n.oid, $9) = $10
        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13
      union all
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,
        $15 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind in ($16, $17)
        AND n.nspname not in ($18, $19, $20)
        AND n.nspname not like $21
        AND n.nspname not like $22
        AND has_schema_privilege(n.oid, $23) = $24
        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27
    ) as tbl
    LEFT JOIN (
      SELECT
        attrelid,
        attname,
        format_type(atttypid, atttypmod) as data_type,
        attnum,
        attisdropped
      FROM
        pg_attribute
    ) as a ON (
      a.attrelid = tbl.quoted_name::regclass
      AND a.attnum > $28
      AND NOT a.attisdropped
      AND has_column_privilege(tbl.quoted_name, a.attname, $29)
    )
  
  GROUP BY schemaname, tablename, quoted_name, is_table",29,279.280009,4.425644,23.150592,9.63034513793104,39,1151,98508,0,100.0000000000000000,0.579311901473561